标题:openssl简介--协议

发信站:BBS水木清华站(FriNov1020:30:492000)

引用请指明原作/译者fordesign@21cn.com


SSL(SecureSocketLayer)是netscape公司提出的主要用于web的安全通信标准,分为2.0版和3.0版.TLS(TransportLayerSecurity)是IETF的TLS工作组在SSL3.0基础之上提出的安全通信标准,目前版本是1.0,即RFC2246.SSL/TLS提供的安全机制可以保证应用层数据在互联网络传输不被监听,伪造和窜改.

一般情况下的网络协议应用中，数据在机器中经过简单的由上到下的几次包装，就进入网络，如果这些包被截获的话，那么可以很容易的根据网络协议得到里面的数据.由网络监听工具可以很容易的做到这一点。

SSL就是为了加密这些数据而产生的协议，可以这么理解，它是位与应用层和TCP/IP之间的一层，数据经过它流出的时候被加密，再往TCP/IP送，而数据从TCP/IP流入之后先进入它这一层被解密，同时它也能够验证网络连接俩端的身份。


它的主要功能就是俩个：
一：加密解密在网络中传输的数据包,同时保护这些数据不被修改,和伪造。
二：验证网络对话中双方的身份

SSL协议包含俩个子协议，一个是包协议，一个是握手协议。包协议是说明SSL的数据包应该如何封装的。握手协议则是说明通信双方如何协商共同决定使用什么算法以及算法使用的key。很明显包协议位于握手协议更下一层。我们暂时对包协议的内容没有兴趣。

SSL握手过程说简单点就是：通信双方通过不对称加密算法来协商好一个对称加密算法以及使用的key,然后用这个算法加密以后所有的数据完成应用层协议的数据交换。


握手一般都是由client发起的，SSL也不例外。

1client送给server它自己本身使用的ssl的version(ssl一共有三个version),加密算法的一些配置，和一些随机产生的数据，以及其他在SSL协议中需要用到的信息。

2server送给client它自己的SSL的version,加密算法的配置，随机产生的数据，还会用自己的私有密钥加密SERVER-HELLO信息。Server还同时把自己的证书文件给送过去。同时有个可选的项目，就是server可以要求需要客户的certificate。

3client就用server送过来的certificate来验证server的身份。如果server身份验证没通过，本次通信结束。通过证书验证之后，得到server的公共密钥，解开server送来的被其用私有密钥加密过的SERVER-HELLO信息，看看对头与否。如果不对，说明对方只有该server的公共密钥而没有私有密钥，必是假的。通信告吹。

4client使用到目前为止所有产生了的随机数据(sharedsecret),client产生本次握手中的premastersecret(这个步骤是有可能有server的参与的，由他们使用的加密算法决定),并且把这个用server的公共密钥加密，送回给server.如果server要求需要验证client,那么client也需要自己把自己的证书送过去，同时送一些自己签过名的数据过去。

SSL协议有俩种技术来产生sharedsecret(真不好意思，又是一个很难意译的词组),
一种是RSA,一种是EDH.

RSA就是我们上一章说过的一种不对称加密算法。首先server把自己的RSA公共密钥送给client,client于是用这个key加密一个随机产生的值(这个随机产生的值就是sharedsecret)，再把结果送给server.

EDH也是一种不对称加密算法，但它与RSA不同的是，它好象没有自己固定的公共密钥和私有密钥，都是在程序跑起来的时候产生的，用完就K掉。其他的步骤俩者就差不多了。

RSA,DSA,DH三种不对称加密算法的区别也就在这里。RSA的密钥固定，后俩个需要一个参数来临时生成key.DH甚至要求双方使用同样的参数，这个参数要事先指定。如果SSL库没有load进这个参数，DH算法就没办法用。DSA没研究过。

5Server验证完client的身份之后，然后用自己的私有密钥解密得到premastersecret然后双方利用这个premastersecret来共同协商，得到mastersecret.

6双方用master一起产生真正的sessionkey,着就是他们在剩下的过程中的对称加密的key了。这个key还可以用来验证数据完整性。双方再交换结束信息。握手结束。

接下来双方就可以用协商好的算法和key来用对称加密算法继续下面的过程了。

很简单吧？其实要复杂一些的，我简化了很多来说。

不过还是有个问题，喜欢捣蛋的人虽然看不懂他们在交流些什么，但篡改总可以吧？
记得我们在加密算法里面介绍过的哈希算法吗？就是为了对付这种捣蛋者的。在每次送信息的时候，附带把整条信息的哈希值也送过去，接收方收到信息的时候，也把收到的内容哈希一把，然后和对方送来的哈希值对比一下，看看是否正确。捣蛋者如果乱改通信内容，哈希出来的值是不同的，那么就很容易被发现了。


但这样子，捣蛋者至少可以学舌。他可以把之前监听到的内容重复发给某一方，而这些内容肯定是正确的,无法验证出有问题的。哎，SSL是怎么对付这种人的我还没看出来。有篇文章说：多放点随机数在信息里可以对付，我也没去研究这句话是什么意思。

 

